지금은 스마트폰 때문에 필요가 없어졌지만, 몇 년 전까지는 영어 단어의 뜻을 찾기 위해 종이로 된 영어사전을 이용했습니다. 단어의 뜻을 찾고 싶을 때, 단어의 철자만 알고 있으면 영어 단어가 **'사전순'으로 나열되어 있다**는 사실을 이용해 단어를 빠르게 찾을 수 있었습니다. 그런데 만약에 영어 사전에 있는 단어들의 순서가 기준이 없이 뒤죽박죽 나열되어 있다면, 단어 하나의 뜻을 찾기 위해서 온 사전을 다 뒤져봐야 할 것입니다.

데이터베이스도 이와 비슷합니다. 검색을 효율적으로 하기 위해 특정 컬럼에 저장된 데이터를 **미리 정렬시켜 놓은 것**을 가지고 **인덱스**라고 부릅니다. 쿼리가 사용할 수 있는 인덱스가 없으면 쿼리는 전체 테이블을 순회하며 검색을 하게 되어 결과를 받을 때까지 시간이 오래 걸리지만, 쿼리가 활용할 수 있는 인덱스가 미리 만들어져있는 상태라면 쿼리 속도가 비약적으로 상승하게 됩니다.

# 인덱스 생성하기

`CREATE INDEX` 구문을 사용해서 인덱스를 생성할 수 있습니다.

```sql
CREATE INDEX ix_from_date ON salaries(from_date);
```

다중 컬럼 인덱스를 생성할 수도 있습니다.

```sql
CREATE INDEX ix_from_date_to_date ON salaries(from_date, to_date);
```

# 인덱스 확인하기

앞에서 생성된 인덱스를 `SHOW INDEX` 구문으로 확인할 수 있습니다.

```sql
SHOW INDEX FROM salaries;
```

# Primary Key, Foreign Key

기본 키와 외래 키에 대해서는 자동으로 인덱스가 생성되기 때문에, 별도의 인덱스를 만들어줄 필요가 없습니다.

# Unique 인덱스

특정 컬럼(혹은 다중 컬럼)의 값을 유일하게 만드는 제약 조건을 걸고 싶을 때 `UNIQUE INDEX`를 사용합니다.

```sql
CREATE UNIQUE INDEX ix_uniq_column ON table_name(col_name);
```

# 인덱스 제거하기

`DROP INDEX` 구문을 이용해 인덱스를 제거할 수 있습니다.

```sql
DROP INDEX index_name ON table_name;
```

# 인덱스의 설계

인덱스는 테이블과는 별도로 저장됩니다. 즉, 인덱스도 디스크의 용량을 차지합니다. 또한 **미리 정렬을 시켜둬야 하는** 인덱스의 성질때문에, 인덱스를 생성한 뒤에는 데이터의 추가나 수정이 느려집니다. 다시 말해서, 인덱스는 **읽기 효율을 높이는 대신 쓰기 효율을 희생시킵니다.**

테이블에 쓰기가 극단적으로 많이 일어나는 경우에는 인덱스 사용을 재고해보는 것이 좋습니다. 그렇지 않은 경우라면, `WHERE` 혹은 `ORDER BY` 구문에서 자주 사용되는 컬럼에 대해서는 인덱스를 걸어두는 것이 좋습니다. 또한 `AND` 연산으로 엮여서 자주 검색되는 컬럼들에 대해서는 다중 컬럼 인덱스를 생성하는 것이 좋습니다.

# 실행 계획

작성한 쿼리가 인덱스를 잘 활용하고 있는지 확인하려면 `EXPLAIN` 구문을 사용해서 실행 계획을 확인할 수 있습니다.

`employees` 데이터베이스에 대해 여러 쿼리를 작성해 보고, 해당 쿼리의 실행계획을 확인해보세요.

`EXPLAIN` 구문에 대한 자세한 설명은 [공식 문서](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)를 참고하세요.